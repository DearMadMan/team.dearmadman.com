<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="php,laravel," />










<meta name="description" content="路由 路由（routing）就是通过互联的网络把信息从源地址传输到目的地址的活动。路由发生在OSI网络参考模型中的第三层即网络层。  基础路由一般所有的路由都被定义在app/Http/routes.php文件中，其中的内容会被框架自动加载，大多数的基础路由都可以通过简单的传递资源表述地址和Closure闭包函数来进行定义。 123Route::get(&apos;foo&apos;, function () &amp;#12">
<meta name="keywords" content="php,laravel">
<meta property="og:type" content="article">
<meta property="og:title" content="laravel 基础教程 —— 路由">
<meta property="og:url" content="http://yoursite.com/2016/04/19/laravel-from-scratch-routing/index.html">
<meta property="og:site_name" content="Team.dearmadman.com">
<meta property="og:description" content="路由 路由（routing）就是通过互联的网络把信息从源地址传输到目的地址的活动。路由发生在OSI网络参考模型中的第三层即网络层。  基础路由一般所有的路由都被定义在app/Http/routes.php文件中，其中的内容会被框架自动加载，大多数的基础路由都可以通过简单的传递资源表述地址和Closure闭包函数来进行定义。 123Route::get(&apos;foo&apos;, function () &amp;#12">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2017-09-13T15:23:23.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="laravel 基础教程 —— 路由">
<meta name="twitter:description" content="路由 路由（routing）就是通过互联的网络把信息从源地址传输到目的地址的活动。路由发生在OSI网络参考模型中的第三层即网络层。  基础路由一般所有的路由都被定义在app/Http/routes.php文件中，其中的内容会被框架自动加载，大多数的基础路由都可以通过简单的传递资源表述地址和Closure闭包函数来进行定义。 123Route::get(&apos;foo&apos;, function () &amp;#12">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2016/04/19/laravel-from-scratch-routing/"/>





  <title>laravel 基础教程 —— 路由 | Team.dearmadman.com</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Team.dearmadman.com</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Just do it.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/04/19/laravel-from-scratch-routing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dearmadman">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Team.dearmadman.com">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">laravel 基础教程 —— 路由</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-04-19T16:28:42+08:00">
                2016-04-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><blockquote>
<p>路由（routing）就是通过互联的网络把信息从源地址传输到目的地址的活动。路由发生在OSI网络参考模型中的第三层即网络层。</p>
</blockquote>
<h2 id="基础路由"><a href="#基础路由" class="headerlink" title="基础路由"></a>基础路由</h2><p>一般所有的路由都被定义在<code>app/Http/routes.php</code>文件中，其中的内容会被框架自动加载，大多数的基础路由都可以通过简单的传递资源表述地址和<code>Closure</code>闭包函数来进行定义。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Route::get(<span class="string">'foo'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'Hello world!'</span>;  </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="基础路由文件"><a href="#基础路由文件" class="headerlink" title="基础路由文件"></a>基础路由文件</h3><p><code>routes.php</code>路由文件是在 <code>app\Providers\RouteServiceProvider.php</code>中被加载的，在被加载的同时使用了<code>web</code>中间件组（version&gt;=5.2), 这个中间件组被定义在<code>app\Http\kernel.php</code>的<code>$middlewareGroups</code>变量中，该中间件组提供了cookie加密、cookie响应、session启用、自动注入error session 到视图、csrf保护的功能。你的应用程序的大多数路由都应该定义在这个路由文件里。</p>
<h3 id="可用的路由方法"><a href="#可用的路由方法" class="headerlink" title="可用的路由方法"></a>可用的路由方法</h3><p>路由允许你在注册路由时使用任何http请求方法：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Route::get($uri, $callback);</div><div class="line">Route::post($uri, $callback);</div><div class="line">Route::put($uri, $callback);</div><div class="line">Route::patch($uri, $callback);</div><div class="line">Route::delete($uri, $callback);</div><div class="line">Route::options($uri, $callback);</div></pre></td></tr></table></figure>
<p>有时候你可能需要在注册路由时允许多种请求方式，这个时候你可能需要使用<code>method</code>方法，当然你可以使用<code>any</code>方法允许任何请求方式:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Route::match([<span class="string">'get'</span>, <span class="string">'post'</span>], <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">// </span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">Route::any(<span class="string">'foo'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">//</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="带参数的路由"><a href="#带参数的路由" class="headerlink" title="带参数的路由"></a>带参数的路由</h2><h3 id="必要参数的路由"><a href="#必要参数的路由" class="headerlink" title="必要参数的路由"></a>必要参数的路由</h3><p>有时候你可能需要捕获路由中的某个片段，比如说用户的id, 那么你就可以定义带参数的路由：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Route::get(<span class="string">'user/&#123;id&#125;'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($id)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'user_id is: '</span> . $id;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p> 可能你需要获取到路由中的多个参数, 那么你可以这么做: </p>
 <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Route::get(<span class="string">'posts/&#123;post&#125;/comments/&#123;comment&#125;'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($post, $comment)</span> </span>&#123;</div><div class="line"> <span class="comment">//</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p> 路由参数就是定义在<code>{}</code>里的，每当该路由被访问到，相关注册的参数就会被按序的传递进闭包函数里.</p>
<p> <code>ps: 路由参数不能含 **-** ，应该使用 **_** 代替，比如 {user_id}</code></p>
<h3 id="可选的参数的路由"><a href="#可选的参数的路由" class="headerlink" title="可选的参数的路由"></a>可选的参数的路由</h3><p>有时候你可能需要定义一个带参数的路由，但是这个参数可有可无，没有的话，可以给予一个默认值，那么这时候就需要用 <code>{name?}</code>的方式来定义可选路由了：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Route::get(<span class="string">'user/&#123;name?&#125;'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($name = null)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> $name; </div><div class="line">&#125;);</div><div class="line"></div><div class="line">Route::get(<span class="string">'user/&#123;name?&#125;'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($name = <span class="string">'john'</span>)</span></span>&#123;</div><div class="line"> <span class="keyword">return</span> $name; </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="用正则表达式约束参数"><a href="#用正则表达式约束参数" class="headerlink" title="用正则表达式约束参数"></a>用正则表达式约束参数</h3><p>你可以使用正则表达式去约束你的参数，这里你可以使用<code>where</code>方法，当参数与约束规则不匹配时就不会匹配到该路由：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Route::get(<span class="string">'user/&#123;name&#125;'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($name)</span></span>&#123;</div><div class="line">  <span class="comment">//</span></div><div class="line">&#125;)</div><div class="line">-&gt;where(<span class="string">'name'</span>, <span class="string">'[a-zA-Z]+'</span>);</div><div class="line">Route::get(<span class="string">'user/&#123;id&#125;'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($id)</span></span>&#123;</div><div class="line"> <span class="comment">// </span></div><div class="line">&#125;)</div><div class="line">-&gt;where(<span class="string">'id'</span>, <span class="string">'[0-9]+'</span>);</div><div class="line">Route::get(<span class="string">'user/&#123;id&#125;/&#123;name&#125;'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($id, $name)</span></span>&#123;</div><div class="line">  <span class="comment">//</span></div><div class="line">&#125;)</div><div class="line">-&gt;where([<span class="string">'id'</span> =&gt; <span class="string">'[0-9]+'</span>, <span class="string">'name'</span> =&gt; <span class="string">'[a-zA-Z]+'</span>);</div></pre></td></tr></table></figure>
<h4 id="全局的约束表达式"><a href="#全局的约束表达式" class="headerlink" title="全局的约束表达式"></a>全局的约束表达式</h4><p>你可以定义全局的约束表达式，这样所有匹配到的路由参数都会受到相同的约束条件, 这个时候你需要在路由启动之前就有注册好约束，你需要在路由服务提供者文件里在启动路由前增加约束。文件是<code>app\Providers\RouteServiceProvider.php</code></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">boot</span><span class="params">(Router $router)</span> </span>&#123;</div><div class="line">  $router-&gt;pattern(<span class="string">'id'</span>, <span class="string">'[0-9]+'</span>);</div><div class="line"></div><div class="line">  <span class="keyword">parent</span>::boot($router);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然，在5.2版本里，路由服务提供者在引入<code>router.php</code>文件时已经注入了<code>$router</code>变量，所以你也可以在<code>router.php</code>文件里这么提供批量约束表达式 :</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$router-&gt;pattern(<span class="string">'id'</span>,<span class="string">'[0-9]+'</span>);</div><div class="line"></div><div class="line">Route::get(<span class="string">'user/&#123;id&#125;'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($id)</span> </span>&#123;</div><div class="line"> <span class="comment">// </span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>但是要注意注册的前后顺序，只有在注册之后引入的路由才受约束，而在 <code>$router-pattern(&#39;id&#39;, &#39;[0-9]+&#39;)</code> 之前注册的路由是不受约束的.</p>
<h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h2><p>命名路由可以方便的生成资源表述地址，可以方便的将路由重定向到指定的路由地址。你可以在注册路由时，传递第二个参数为数组参数，并添加<code>as</code>索引：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Route::get(<span class="string">'user/profile'</span>, [<span class="string">'as'</span> =&gt; <span class="string">'profile'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">//</span></div><div class="line">&#125;]);</div></pre></td></tr></table></figure></p>
<p>当然你也可以命名使用控制器行为的路由：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Route::get(<span class="string">'user/profile'</span>, [<span class="string">'as'</span> =&gt; <span class="string">'profile'</span>, <span class="string">'use'</span> =&gt; <span class="string">'UserController@showProfile'</span>]);</div></pre></td></tr></table></figure></p>
<p>有时候数组写起来比较麻烦，我们还可以使用<code>name</code>方法去命名路由，当然它是支持链式调用的:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Route::get(<span class="string">'user/profile'</span>, <span class="string">'UserController@showProfile'</span>)-&gt;name(<span class="string">'profile'</span>);</div></pre></td></tr></table></figure></p>
<h3 id="路由组-amp-命名组路由"><a href="#路由组-amp-命名组路由" class="headerlink" title="路由组 &amp; 命名组路由"></a>路由组 &amp; 命名组路由</h3><p>如果你使用了路由组，你可能想在整个组中增加一个组命名前缀，当然，laravel是支持这么做的：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Route::group([<span class="string">'as'</span> =&gt; <span class="string">'admin::'</span>], <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">  Route::get(<span class="string">'dashboard'</span>, [<span class="string">'as'</span> =&gt; <span class="string">'dashboard'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// route named 'admin::dashboard'</span></div><div class="line">    <span class="comment">// you can redirect to this use route('admin::dashboard')</span></div><div class="line">  &#125;]) ;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="使用命名路由生成urls"><a href="#使用命名路由生成urls" class="headerlink" title="使用命名路由生成urls"></a>使用命名路由生成urls</h3><p>一旦你命名了一个路由，那么你就可以使用全局帮助函数<code>route</code>来生成路由url地址，也可以用来做为重定向时生成重定向地址:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Generating URLs...</span></div><div class="line">$url = route(<span class="string">'profile'</span>);</div><div class="line"></div><div class="line"><span class="comment">// Generating Redirects...</span></div><div class="line"><span class="keyword">return</span> redirect()-&gt;route(<span class="string">'profile'</span>);</div></pre></td></tr></table></figure></p>
<p>如果你是对一个参数路由进行命名，那么你可以在使用<code>route</code>方法获取路由url时传递第二个参数，该参数是一个数组，你所传递的参数会正确的按索引匹配到相应的位置,如果参数索引与路由参数不一致，则会优先匹配相同的参数存放到相应位置，不一致的会按序存入：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Route::get(<span class="string">'user/&#123;id&#125;/profile'</span>, [<span class="string">'as'</span> =&gt; <span class="string">'profile'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($id)</span> </span>&#123;</div><div class="line"> <span class="comment">// </span></div><div class="line">&#125;]);</div><div class="line">$url = route(<span class="string">'profile'</span>, [<span class="string">'id'</span> =&gt; <span class="number">1</span>]);</div></pre></td></tr></table></figure></p>
<h2 id="路由组"><a href="#路由组" class="headerlink" title="路由组"></a>路由组</h2><p>路由组的使用方便共享路由的一些能力，比如共享中间件，或者命名空间，这样就不必每一个路由都要单独去定义一次相同的中间件或命名空间。路由组使用 <code>Route::group</code>去定义，并共享第一个参数中的能力.该参数为数组.</p>
<h3 id="共享中间件"><a href="#共享中间件" class="headerlink" title="共享中间件"></a>共享中间件</h3><p>你可以使用<code>middleware</code>索引来建立共享中间件,这样路由组内定义的路由都会在匹配时引入该中间件:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Route::group([<span class="string">'middleware'</span> =&gt; <span class="string">'auth'</span>], <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">  Route::get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// Uses Auth Middleware</span></div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  Route::get(<span class="string">'user/profile'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// Uses Auth Middleware</span></div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="共享命名空间"><a href="#共享命名空间" class="headerlink" title="共享命名空间"></a>共享命名空间</h3><p>路由组另外一个常用的例子就是在控制器中共享命名空间，这个时候就要用到了<code>namespace</code>索引:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Route::group([<span class="string">'namespace'</span> =&gt; <span class="string">'Admin'</span>], <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">   <span class="comment">// Controllers Within The 'App\Http\Controllers\Admin' Namespace </span></div><div class="line"></div><div class="line">   Route::group([<span class="string">'namespace'</span> =&gt; <span class="string">'User'</span>], <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">     <span class="comment">//  Controllers Within The 'App\Http\Controllers\Admin\User' Namespace</span></div><div class="line">   &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>因为我们大部分路由都是定义在<code>routes.php</code>文件里，而路由服务在提供服务时将该文件引入到路由组中,并共享了<code>App\Http\Controllers</code>命名空间，这样，在该文件中定义的控制器路由，可以不使用<code>App\Http\Controllers</code>前缀.</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Already Within The 'App\Http\Controllers' Namespace</span></div><div class="line">Route::get(<span class="string">'user/profile'</span>, <span class="string">'UserController@showProfile'</span>);</div></pre></td></tr></table></figure>
<h3 id="子域名路由"><a href="#子域名路由" class="headerlink" title="子域名路由"></a>子域名路由</h3><p>子域名路由可以做域名匹配路由，也就是说可以约束域名做匹配，如果不是匹配到的域名则不会注册该组内路由， 当然你可以对子域名进行类参数路由的约束，这样允许你捕获域名的一部分或全部:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Route::group([<span class="string">'domain'</span> =&gt; <span class="string">'&#123;account&#125;.myapp.com'</span>], <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">  Route::get(<span class="string">'user/&#123;id&#125;'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($account, $id)</span> </span>&#123;</div><div class="line">    <span class="comment">//</span></div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="路由前缀"><a href="#路由前缀" class="headerlink" title="路由前缀"></a>路由前缀</h3><p>使用<code>prefix</code>索引可以在路由组中定义路由前缀，这样在该组内的路由都会自动使用该前缀：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Route::group([<span class="string">'prefix'</span> =&gt; <span class="string">'admin'</span>], <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">  Route::get(<span class="string">'dashboard'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// Matches The 'admin/dashboard' URL</span></div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当然你可以在路由前缀中使用参数：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Route::group([<span class="string">'prefix'</span> =&gt; <span class="string">'accounts/&#123;account_id&#125;'</span>], <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">  Route::get(<span class="string">'detail'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($account_id)</span> </span>&#123;</div><div class="line">    <span class="comment">// Matchs The '/accounts/&#123;account_id&#125;/detail' URL</span></div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="CSRF-保护"><a href="#CSRF-保护" class="headerlink" title="CSRF 保护"></a>CSRF 保护</h2><blockquote>
<p>跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。<br>跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。</p>
</blockquote>
<p>laravel框架自带csrf攻击保护措施，它被以中间件的形式引入到<code>web</code>路由组中，所以每个在<code>routes.php</code>文件中定义的路由被访问时都会经过csrf中间件的验证。你可以查看<code>vendor/laravel/framework/src/Illuminate/Foundation/Http/Middleware/VerifyCsrfToken.php</code>文件，阅读其实现。<br><code>csrf(跨站请求伪造)</code>是一种恶意的攻击行为，它可以绕过用户的授权去执行未授权的行为。</p>
<p>laravel会为每个活跃用户生成一个csrf token,而这个token就是用来验证请求是不是真实用户授权的。所以你应该在每个表单中都使用隐藏的input并录入csrf token,这样提交表单的请求才能通过csrf中间件的验证.<br>laravel提供了方便的形式去在表单中生成csrf token:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Vanilla PHP</span></div><div class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> csrf_field(); <span class="meta">?&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Blade Template Syntax</span></div><div class="line">&#123;&#123; csrf_field() &#125;&#125;</div></pre></td></tr></table></figure>
<p><code>csrf_field()</code>方法会生成以下html节点：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input type=<span class="string">"hidden"</span> name=<span class="string">"_token"</span> value=<span class="string">"&lt;?php echo csrf_token(); ?&gt;"</span>&gt;</div></pre></td></tr></table></figure>
<p>你并不需要去手动的验证这些能够修改状态的http请求，比如 post, put, delete, 因为VerifyCsrfToken中间件已经自动处理这些请求了，它会自动的根据请求中的token与会话中存储的token进行匹配验证。</p>
<h3 id="排除csrf保护"><a href="#排除csrf保护" class="headerlink" title="排除csrf保护"></a>排除csrf保护</h3><p>有时候我们可能需要排除个别url，让他不受csrf的保护，因为可能我们需要挂接一些其他的第三方系统，这个时候系统之间的通讯是不应该使用csrf机制去验证的，比如说，你使用了支付宝的即时付款机制，那么在用户付款的时候服务器与服务器之间会有一个回馈机制，用于支付宝通知我们的应用用户已经成功付款，这个时候我们可能需要排除csrf对反馈路由的保护。那么我们可以在<code>VerifyCsrfToken</code>中间件中修改<code>$except</code>属性中增加一条规则:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Middleware</span>;</div><div class="line"></div><div class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Foundation</span>\<span class="title">Http</span>\<span class="title">Middleware</span>\<span class="title">VerifyCsrfToken</span> <span class="title">as</span> <span class="title">BaseVerifier</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">VerifyCsrfToken</span> <span class="keyword">extends</span> <span class="title">BaseVerifier</span></span></div><div class="line"><span class="class"></span>&#123;</div><div class="line">   <span class="comment">/** </span></div><div class="line"><span class="comment">    * The URIs that should be excluded from CSRF verification.</span></div><div class="line"><span class="comment">    * </span></div><div class="line"><span class="comment">    * <span class="doctag">@var</span> array</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">protected</span> $except = [</div><div class="line">    <span class="string">'alipay/*'</span>,</div><div class="line">   ];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="X-CSRF-TOKEN"><a href="#X-CSRF-TOKEN" class="headerlink" title="X-CSRF-TOKEN"></a>X-CSRF-TOKEN</h3><p>laravel的<code>VerifyCsrfToken</code>中间件不仅允许通过表单中验证_token参数，它也允许通过请求头去进行csrf验证，它会验证请求头中的<code>X-CSRF-TOKEN</code>值是否与会话的token值匹配，所以你可以这么做，存储token到<code>meta</code>中：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"csrf-token"</span> <span class="attr">content</span>=<span class="string">"&#123;&#123; csrf_token() &#125;&#125;"</span> &gt;</span></div></pre></td></tr></table></figure></p>
<p>一旦你定义了<code>meta</code>标签，你可以使用像<code>jquery</code>类似的框架去添加token到所有请求的头部:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$.ajaxSetup(&#123;</div><div class="line">  headers: &#123;</div><div class="line">    <span class="string">'X-CSRF-TOKEN'</span>: $(<span class="string">'meta[name="csrf-token"]'</span>).attr(<span class="string">'content'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="X-XSRF-TOKEN"><a href="#X-XSRF-TOKEN" class="headerlink" title="X-XSRF-TOKEN"></a>X-XSRF-TOKEN</h3><p>laravel自动存储了CSRF token 到 cookie中并被命名为 <code>XSRF-TOKEN</code>, 你可以在每次请求的请求头里引入<code>X-XSRF-TOKEN</code>并将其值设置为 <code>XSRF-TOKEN</code>的cookie值来通过csrf验证。有一些javascript框架里已经自动做了这些，像 angularjs. 如果你没有引入这些前端框架，你可能需要自己手动去做了:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fetch(<span class="string">'/user/password'</span>, &#123;</div><div class="line">  method: <span class="string">'POST'</span>,</div><div class="line">  headers: &#123;</div><div class="line">    <span class="string">'X-XSRF-TOKEN'</span>: </div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="绑定模型的路由"><a href="#绑定模型的路由" class="headerlink" title="绑定模型的路由"></a>绑定模型的路由</h2><p>绑定模型的路由提供了一种便利的方式去注入模型实例到路由中，比如，你可以通过传递id，来注入匹配id的用户的整个模型到路由中。</p>
<h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><p>laravel会自动的解析定义在路由或者控制器中的<code>Eloquent</code>模型, 根据变量名与参数名匹配的，比如<code>api/users/{user}</code> 匹配 <code>$user</code>变量：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Route::get(<span class="string">'api/users/&#123;user&#125;'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(App\User $user)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> $user-&gt;email; </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>在上面的例子中，$user是根据url中<code>{user}</code>片段的值进行实例生成的.这种绑定模型到路由一般都是默认根据id进行匹配注入实例。比如说 <code>users/1</code>，匹配到的就是id = 1的用户实例。如果没有匹配的实例，则会返回404。</p>
<h3 id="自定义索引绑定模型到路由"><a href="#自定义索引绑定模型到路由" class="headerlink" title="自定义索引绑定模型到路由"></a>自定义索引绑定模型到路由</h3><p>如果你不想用id去绑定模型到路由，laravel提供了一种可自定义的方式，你只需要在相应的模型里重写<code>getRouteKeyName</code>方法就行了，比如我们用名字来代替id注入模型到路由:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getRouteKeyName</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'name'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样在路由url中就是类似这种形式了 <code>users/wang</code></p>
<h3 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h3><p>如果需要注册一种显式的模型绑定到路由，你需要使路由的<code>model</code>方法去指定类与参数的映射。并且你应该在路由服务的<code>boot</code>方法中进行绑定注册操作：</p>
<h3 id="绑定到模型"><a href="#绑定到模型" class="headerlink" title="绑定到模型"></a>绑定到模型</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">boot</span><span class="params">(Router $router)</span> </span>&#123;</div><div class="line">  <span class="keyword">parent</span>::boot($router);</div><div class="line"></div><div class="line">  $router-&gt;model(<span class="string">'user'</span>, <span class="string">'App\User'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，在<code>routes.php</code>文件中注册的路由如果使用了<code>{user}</code>的命名路由就可以自动绑定到模型:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$router-&gt;get(<span class="string">'profile/&#123;user&#125;'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(App\User $user)</span> </span>&#123;</div><div class="line"> <span class="comment">// </span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="自定义绑定解析逻辑"><a href="#自定义绑定解析逻辑" class="headerlink" title="自定义绑定解析逻辑"></a>自定义绑定解析逻辑</h3><p>如果你想自定义解析返回实例的逻辑，那么你需要使用<code>Route::bind</code>方法，该方法第一个参数为绑定url的参数名，第二个参数为<code>Closure</code>, 闭包中会接收一个参数，这个参数是url中对应参数片段的值，你应该在闭包中返回解析后的实例：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$router-&gt;bind(<span class="string">'user'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($value)</span> </span>&#123;</div><div class="line"> <span class="keyword">return</span> App\User::where(<span class="string">'name'</span>, $value)-&gt;first(); </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="自定义找不到实例时的行为"><a href="#自定义找不到实例时的行为" class="headerlink" title="自定义找不到实例时的行为"></a>自定义找不到实例时的行为</h3><p>如果你想要自定义无法匹配实例时的行为，你可以向<code>model</code>方法传递第三个参数，该参数是一个闭包函数，它将在无法匹配到实例时执行：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$router-&gt;model(<span class="string">'user'</span>, <span class="string">'App\User'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> NotFoundHttpException;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="表单提交方式模拟"><a href="#表单提交方式模拟" class="headerlink" title="表单提交方式模拟"></a>表单提交方式模拟</h2><p>由于HTML的表单不能支持像<code>PUT</code>,<code>PATCH</code>或者<code>DELETE</code>的请求方式，所以，当需要访问类似的路由时，你需要在表单中增加一个隐藏的字段<code>_method</code>，用来表明你真实的表单请求方式:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">“/foo/bar</span>" <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"_method"</span> <span class="attr">value</span>=<span class="string">"PUT"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"_token"</span> <span class="attr">value</span>=<span class="string">"&#123;&#123; csrf_token() &#125;&#125;"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure>
<p>laravel也提供了便捷生成隐藏字段<code>_method</code>的方法，你可以使用<code>method_field</code>帮助方法：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> method_field(); <span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<p>使用blade模板引擎可以直接这么用：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&#123; method_field(<span class="string">'PUT'</span>) &#125;&#125;</div></pre></td></tr></table></figure></p>
<h2 id="访问当前路由"><a href="#访问当前路由" class="headerlink" title="访问当前路由"></a>访问当前路由</h2><p><code>Route::current()</code> 会返回一个<code>Illuminate\Routing\Route</code>的实例，它允许你在当前路由内处理相关请求：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$route = Route::current();</div><div class="line"></div><div class="line">$name = $route-&gt;getName();</div><div class="line"></div><div class="line">$actionName = $route-&gt;getActionName();</div></pre></td></tr></table></figure>
<p>当然你也可以通过<code>Route</code>facade去访问路由的name或action:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$name = Route::currentRouteName();</div><div class="line"></div><div class="line">$action = Route::currentRouteAction();</div></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/php/" rel="tag"># php</a>
          
            <a href="/tags/laravel/" rel="tag"># laravel</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/04/18/laravel-from-scratch-configuration/" rel="next" title="laravel 基础教程 —— 配置">
                <i class="fa fa-chevron-left"></i> laravel 基础教程 —— 配置
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/04/21/what-is-jwt/" rel="prev" title="什么是 JWT -- JSON WEB TOKEN">
                什么是 JWT -- JSON WEB TOKEN <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Dearmadman</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">100</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#路由"><span class="nav-number">1.</span> <span class="nav-text">路由</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基础路由"><span class="nav-number">1.1.</span> <span class="nav-text">基础路由</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础路由文件"><span class="nav-number">1.1.1.</span> <span class="nav-text">基础路由文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可用的路由方法"><span class="nav-number">1.1.2.</span> <span class="nav-text">可用的路由方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#带参数的路由"><span class="nav-number">1.2.</span> <span class="nav-text">带参数的路由</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#必要参数的路由"><span class="nav-number">1.2.1.</span> <span class="nav-text">必要参数的路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可选的参数的路由"><span class="nav-number">1.2.2.</span> <span class="nav-text">可选的参数的路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用正则表达式约束参数"><span class="nav-number">1.2.3.</span> <span class="nav-text">用正则表达式约束参数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#全局的约束表达式"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">全局的约束表达式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命名路由"><span class="nav-number">1.3.</span> <span class="nav-text">命名路由</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#路由组-amp-命名组路由"><span class="nav-number">1.3.1.</span> <span class="nav-text">路由组 & 命名组路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用命名路由生成urls"><span class="nav-number">1.3.2.</span> <span class="nav-text">使用命名路由生成urls</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#路由组"><span class="nav-number">1.4.</span> <span class="nav-text">路由组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#共享中间件"><span class="nav-number">1.4.1.</span> <span class="nav-text">共享中间件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共享命名空间"><span class="nav-number">1.4.2.</span> <span class="nav-text">共享命名空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子域名路由"><span class="nav-number">1.4.3.</span> <span class="nav-text">子域名路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#路由前缀"><span class="nav-number">1.4.4.</span> <span class="nav-text">路由前缀</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CSRF-保护"><span class="nav-number">1.5.</span> <span class="nav-text">CSRF 保护</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#排除csrf保护"><span class="nav-number">1.5.1.</span> <span class="nav-text">排除csrf保护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#X-CSRF-TOKEN"><span class="nav-number">1.5.2.</span> <span class="nav-text">X-CSRF-TOKEN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#X-XSRF-TOKEN"><span class="nav-number">1.5.3.</span> <span class="nav-text">X-XSRF-TOKEN</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#绑定模型的路由"><span class="nav-number">1.6.</span> <span class="nav-text">绑定模型的路由</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#隐式绑定"><span class="nav-number">1.6.1.</span> <span class="nav-text">隐式绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义索引绑定模型到路由"><span class="nav-number">1.6.2.</span> <span class="nav-text">自定义索引绑定模型到路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#显式绑定"><span class="nav-number">1.6.3.</span> <span class="nav-text">显式绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#绑定到模型"><span class="nav-number">1.6.4.</span> <span class="nav-text">绑定到模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义绑定解析逻辑"><span class="nav-number">1.6.5.</span> <span class="nav-text">自定义绑定解析逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义找不到实例时的行为"><span class="nav-number">1.6.6.</span> <span class="nav-text">自定义找不到实例时的行为</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#表单提交方式模拟"><span class="nav-number">1.7.</span> <span class="nav-text">表单提交方式模拟</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问当前路由"><span class="nav-number">1.8.</span> <span class="nav-text">访问当前路由</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dearmadman</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
